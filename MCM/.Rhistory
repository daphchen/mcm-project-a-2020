next
}
# corresponding indices for surrounding blocks
north <- current_block-20
west <- current_block-1
south <- current_block+20
east <- current_block+1
northwest <- current_block-21
southwest <- current_block+19
southeast <- current_block+21
northeast <- current_block-19
# vector to keep track of which adjacent blocks are within temperature range
if(current_block %in% left_edge) {
adjacent <- c(north, south, east, southeast, northeast)
} else if(current_block %in% right_edge) {
adjacent <- c(north, west, south, northwest, southwest)
} else {
adjacent <- c(north, west, south, east, northwest, southwest, southeast, northeast)
}
# average temperature of range in the case that none of the block are within range
avg_temp <- 11
# best option if no blocks are within temperature range
best <- abs(avg_temp - current_block_temp)
# initialize what the index of the new block to be migrated to
new_block <- current_block
adjacent_copy <- adjacent
# check whether we have data for each direction AND if the block is above or below threshold temperature
for(direction in adjacent) {
# if block is out of range (no data) or not within temperature range, remove the option from the adjacent vector
if(direction > 300 || direction < 1) {
adjacent_copy <- adjacent_copy[adjacent_copy != direction]
next
}
temp <- sst[[direction, as.character(current_year)]]
if(is.na(temp)) {
adjacent_copy <- adjacent_copy[adjacent_copy != direction]
next
}
if(!(10.5 <= temp & temp <= 11.5)) {
if(abs(avg_temp - temp) < best) {
best <- abs(avg_temp - temp)
new_block <- direction
}
if(new_block == current_block && north > 0 && !is.na(sst[[north, 2]])) {
new_block <- north
}
adjacent_copy <- adjacent_copy[adjacent_copy != direction]
}
}
# of the blocks that are in temperature range, choose one at random to migrate to
if(length(adjacent_copy) > 1) {
new_block <- sample(adjacent_copy, 1)
}
if(length(adjacent_copy) == 1) {
new_block <- adjacent_copy
}
# if new block is a previous block and not in temp range, move north
if(new_block == prev_block) {
if(!(10.5 <= current_block_temp & current_block_temp <= 11.5) && north > 0 && !is.na(sst[[north, 2]])) {
new_block <- north
}
}
# increment year
current_year <- current_year + 1
prev_block <- current_block
current_block <- new_block
# migration_pat <- c(migration_pat, sst[[new_block, 1]])
best_case_herr_df[i, j] <- sst[[new_block, 1]]
j <- j + 1
}
}
write.csv(best_case_herr_df, file = "bc_herring.csv")
#write.csv(year_out, file = "bch_years.csv")
write.csv(year_out, file = "bch_years_f.csv")
#***************************************************************************
# BEST CASE MODEL FOR MACKEREL
# Dataset:
#     "forecast_sst_50_t.csv"      forecasted data from 2020-2069, transposed
# Author: Daphne Chen
#***************************************************************************
# Best case sst range parameter: 9.8-10.25 C
#***************************************************************************
# Library needed packages
library(tidyverse)
set.seed(42)
# Import forecasted data
sst = read_csv("forecast_sst_50_t.csv", col_names = TRUE)
head(sst)
# Data frame to keep track of each run of the model
# Each row is a simulation
# Each col is an year
best_case_mack_df <- data.frame(matrix(NA, nrow = 100, ncol = 51))
# track what year fish leave "within reach"
year_out <- rep(NA, times = 100)
left_edge <- seq(from=1, to=300, by=20)
right_edge <- seq(from=20, to=300, by=20)
within <- c(53:59, 73:79, 94:99, 115:119, 136:139, 157:159, 178, 179, 199)
#c(95, 96, 97, 115, 116, 117, 135, 136, 137, 157))
for(i in 1:100) {
best_case_mack_df[i, 1] <- sst[[116, 1]] #  Starting location = first entry of each row
# Start block index and year
current_block <- 116 # 60.5, -0.5
current_year <- 2020
prev_block <- 0
first_yr_out <- TRUE
j <- 2 # column tracker
while(current_year < 2070 & current_block > 0) {
if(first_yr_out) {
# port coordinate
if(!(current_block %in% within)) {
year_out[i] <- current_year
first_yr_out <- FALSE
}
}
# Check if current location's temperature is still within habitable range
current_block_temp <- sst[[current_block, as.character(current_year)]]
if(9.8 <= current_block_temp & current_block_temp <= 10.25) {
current_year <- current_year + 1
best_case_mack_df[i, j] <- sst[[current_block, 1]]
j <- j + 1
next
}
# Corresponding indices for surrounding blocks
north <- current_block-20
west <- current_block-1
south <- current_block+20
east <- current_block+1
northwest <- current_block-21
southwest <- current_block+19
southeast <- current_block+21
northeast <- current_block-19
# Vector to keep track of which adjacent blocks are within temperature range
if(current_block %in% left_edge) {
adjacent <- c(north, south, east, southeast, northeast)
} else if(current_block %in% right_edge) {
adjacent <- c(north, west, south, northwest, southwest)
} else {
adjacent <- c(north, west, south, east, northwest, southwest, southeast, northeast)
}
# Average temperature of range in the case that none of the block are within range
avg_temp <- 10.025
# Best option if no blocks are within temperature range
best <- abs(avg_temp - current_block_temp)
# Initialize what the index of the new block to be migrated to
new_block <- current_block
adjacent_copy <- adjacent
# Check whether we have data for each direction AND
# if the block is above or below threshold temperature
for(direction in adjacent) {
# if block is out of range (no data) or not within temperature range,
# remove the option from the adjacent vector
if(direction > 300 || direction < 1) {
adjacent_copy <- adjacent_copy[adjacent_copy != direction]
next
}
temp <- sst[[direction, as.character(current_year)]]
if(is.na(temp)) {
adjacent_copy <- adjacent_copy[adjacent_copy != direction]
next
}
if(!(9.8 <= temp & temp <= 10.25)) {
if(abs(avg_temp - temp) < best) {
best <- abs(avg_temp - temp)
new_block <- direction
}
if(new_block == current_block & north > 0 & !is.na(sst[[north, 2]])) {
new_block <- north
}
adjacent_copy <- adjacent_copy[adjacent_copy != direction]
}
}
# of the blocks that are in temperature range, choose one at random to migrate to
if(length(adjacent_copy) > 1) {
new_block <- sample(adjacent_copy, 1)
}
if(length(adjacent_copy) == 1) {
new_block <- adjacent_copy
}
# If new block is a previous block and not in temp range, move north
if(new_block == prev_block) {
if(!(9.8 <= current_block_temp & current_block_temp <= 10.25) & north > 0 & !is.na(sst[[north, 2]])) {
new_block <- north
}
}
# Increment year
current_year <- current_year + 1
prev_block <- current_block
current_block <- new_block
# Migration_pat <- c(migration_pat, sst[[new_block, 1]])
best_case_mack_df[i, j] <- sst[[new_block, 1]]
j <- j + 1
}
}
write.csv(best_case_mack_df, file = "bc_mackerel.csv")
#write.csv(year_out, file = "bcm_years.csv")
write.csv(year_out, file = "bcm_years_f.csv")
bcm_years <- read.csv("bcm_years.csv")
bcm_years <- bcm_years[,2]
bcm_years <- factor(bcm_years)
wcm_years <- read.csv("wcm_years.csv")
wcm_years <- wcm_years[,2]
wcm_years <- factor(wcm_years)
bch_years <- read.csv("bch_years.csv")
bch_years <- bch_years[,2]
bch_years <- factor(bch_years)
wch_years <- read.csv("wch_years.csv")
wch_years <- wch_years[,2]
wch_years <- factor(wch_years)
table(bcm_years)/100
table(wcm_years)/100
table(bch_years)/100
table(wch_years)/100
bcm_years <- read.csv("bcm_years_f.csv")
bcm_years <- bcm_years[,2]
bcm_years <- factor(bcm_years)
table(bcm_years)/100
wcm_years <- read.csv("wcm_years_f.csv")
wcm_years <- wcm_years[,2]
wcm_years <- factor(wcm_years)
table(wcm_years)/100
bch_years <- read.csv("bch_years_f.csv")
bch_years <- bch_years[,2]
bch_years <- factor(bch_years)
table(bch_years)/100
wch_years <- read.csv("wch_years_f.csv")
wch_years <- wch_years[,2]
wch_years <- factor(wch_years)
table(wch_years)/100
table(bcm_years)/100
table(wcm_years)/100
table(bch_years)/100
table(wch_years)/100
#***************************************************************************
# Computing Fish Density q USING OLD STARTING POINT
# Dataset:
#		"forecast_sst_50.csv"      	2020-2069
#		"bc_herring.csv"      		end coordinates of best case herring
#		"bc_mackerel.csv"      		end coordinates of best case mackerel
# Author: Hao Jin
#***************************************************************************
library(tidyverse)
library('plot.matrix')
library(stringr)
library("viridis")
library(RColorBrewer)
forecast = read.csv("forecast_sst_50_t.csv", row.names = 1)
bc_herr = read_csv("bc_herring.csv", col_names = TRUE)
bc_mack = read_csv("bc_mackerel.csv", col_names = TRUE)
# Current fishing port, old fishing boat covers
# 95,  96,  97,
# 115, 116, 117,
#      136, 137
#			157
# Current fishing port, new fishing boat covers
# 53, 54, 55, 56, 57, 58, 59
# 73, 74, 75, 76, 77, 78, 79
#     94, 95, 96, 97, 98, 99
#		  115,116,117,118,119
#			  136,137,138,139
#			  	  157,158,159
#				      178,179
#						  199
# Move south, old fishing boat covers
# 137,138,139
# 157,158,159
# 	  178,179
#		  199
# Move south, old fishing boat covers
# 74, 75, 76
# 94, 95, 96
# 114,115,116
#         136
# ------------------------------------------ Herring ------------------------------------------ #
years_of_interest = seq(2019, 2069)
years_col = years_of_interest - 2019 + 2
current_herr = numeric(51)
new_boat_herr = numeric(51)
move_south_herr = numeric(51)
move_north_herr = numeric(51)
for (n in years_col){
# Create empty vectors to store location (lat,lon) info
latitude <- numeric(100)
longitude <- numeric(100)
for (i in seq_len(100)) {
xy <- str_split(bc_herr[i,n], " ")
latitude[i] <- as.numeric(xy[[1]][1])
longitude[i] <- as.numeric(xy[[1]][2])
}
# Create empty vectors to store location (row,col) info
row_num <- numeric(100)
col_num <- numeric(100)
for (i in seq_len(100)) {
row_num[i] = 62.5 - latitude[i] + 1
col_num[i] = longitude[i] + 16.5 + 1
}
# Create empty vectors to store location (block number) info
# Up to down, left to right
# First block: 62.5, -16.5
# 300th block: 48.5, 2.5
num <- numeric(100)
for (i in seq_len(100)) {
num[i] = 20 * row_num[i] + col_num[i]
}
table(num)
# Create empty vectors to count ending block number
counter = numeric(300)
# Mark Land
for (i in seq_len(300)) {
if(is.na(forecast[i,11]))
counter[i] = NA
}
for (block in num) {
counter[block] = counter[block] + 1
}
current_herr[n-1] = sum(counter[c(	95, 96, 97,
115,116,117,
136,137,
157)])
new_boat_herr[n-1] = sum(counter[c(	53, 54, 55, 56, 57, 58, 59,
73, 74, 75, 76, 77, 78, 79,
94, 95, 96, 97, 98, 99,
115,116,117,118,119,
136,137,138,139,
157,158,159,
178,179,
199)])
move_south_herr[n-1] = sum(counter[c( 137,138,139,
157,158,159,
178,179,
199)])
move_north_herr[n-1] = sum(counter[c( 74, 75, 76,
94, 95, 96,
115,116,
136)])
}
current_herr
new_boat_herr
move_south_herr
move_north_herr
q_herr = data.frame("current" = current_herr,
"new boat" = new_boat_herr,
"move north" = move_south_herr,
"move_south" = move_north_herr)
rownames(q_herr) = seq(2019,2069)
write.csv(q_herr, "q_herring.csv")
# ------------------------------------------ Mackerel ------------------------------------------ #
years_of_interest = seq(2019, 2069)
years_col = years_of_interest - 2019 + 2
current_mack = numeric(51)
new_boat_mack = numeric(51)
move_south_mack = numeric(51)
move_north_mack = numeric(51)
for (n in years_col){
# Create empty vectors to store location (lat,lon) info
latitude <- numeric(100)
longitude <- numeric(100)
for (i in seq_len(100)) {
xy <- str_split(bc_mack[i,n], " ")
latitude[i] <- as.numeric(xy[[1]][1])
longitude[i] <- as.numeric(xy[[1]][2])
}
# Create empty vectors to store location (row,col) info
row_num <- numeric(100)
col_num <- numeric(100)
for (i in seq_len(100)) {
row_num[i] = 62.5 - latitude[i] + 1
col_num[i] = longitude[i] + 16.5 + 1
}
# Create empty vectors to store location (block number) info
# Up to down, left to right
# First block: 62.5, -16.5
# 300th block: 48.5, 2.5
num <- numeric(100)
for (i in seq_len(100)) {
num[i] = 20 * row_num[i] + col_num[i]
}
table(num)
# Create empty vectors to count ending block number
counter = numeric(300)
# Mark Land
for (i in seq_len(300)) {
if(is.na(forecast[i,11]))
counter[i] = NA
}
for (block in num) {
counter[block] = counter[block] + 1
}
current_mack[n-1] = sum(counter[c(	95, 96, 97,
115,116,117,
136,137,
157)])
new_boat_mack[n-1] = sum(counter[c(	53, 54, 55, 56, 57, 58, 59,
73, 74, 75, 76, 77, 78, 79,
94, 95, 96, 97, 98, 99,
115,116,117,118,119,
136,137,138,139,
157,158,159,
178,179,
199)])
move_south_mack[n-1] = sum(counter[c( 137,138,139,
157,158,159,
178,179,
199)])
move_north_mack[n-1] = sum(counter[c( 74, 75, 76,
94, 95, 96,
115,116,
136)])
}
current_mack
new_boat_mack
move_south_mack
move_north_mack
q_mack = data.frame("current" = current_mack,
"new boat" = new_boat_mack,
"move north" = move_south_mack,
"move_south" = move_north_mack)
rownames(q_mack) = seq(2019,2069)
write.csv(q_mack, "q_mackerel.csv")
View(bc_mack)
bcm_years <- read_csv("bcm_years.csv")
bcm_years <- bcm_years[,2]
# histogram
ggplot(bcm_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Best Case Mackerel")
ggsave("bcm_y_hist.png")
bcm_f <- factor(bcm_years[[1]])
table(bcm_f)
wcm_years <- read_csv("wcm_years.csv")
wcm_years <- wcm_years[,2]
ggplot(wcm_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Worst Case Mackerel")
ggsave("wcm_y_hist.png")
wcm_f <- factor(wcm_years[[1]])
table(wcm_f)
bch_years <- read_csv("bch_years.csv")
bch_years <- bch_years[,2]
ggplot(bch_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Best Case Herring")
ggsave("bch_y_hist.png")
bch_f <- factor(bch_years[[1]])
table(bch_f)
wch_years <- read_csv("wch_years.csv")
wch_years <- wch_years[,2]
ggplot(wch_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Worst Case Herring")
ggsave("wch_y_hist.png")
wch_f <- factor(wch_years[[1]])
table(wch_f)
library(tidyverse)
bcm_years <- read_csv("bcm_years.csv")
bcm_years <- bcm_years[,2]
# histogram
ggplot(bcm_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Best Case Mackerel")
ggsave("bcm_y_hist.png")
bcm_f <- factor(bcm_years[[1]])
table(bcm_f)
wcm_years <- read_csv("wcm_years.csv")
wcm_years <- wcm_years[,2]
ggplot(wcm_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Worst Case Mackerel")
ggsave("wcm_y_hist.png")
wcm_f <- factor(wcm_years[[1]])
table(wcm_f)
bch_years <- read_csv("bch_years.csv")
bch_years <- bch_years[,2]
ggplot(bch_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Best Case Herring")
ggsave("bch_y_hist.png")
bch_f <- factor(bch_years[[1]])
table(bch_f)
wch_years <- read_csv("wch_years.csv")
wch_years <- wch_years[,2]
ggplot(wch_years, aes(x=x)) +
geom_histogram(aes(y=..count..), color="green", fill="white") +
geom_density(alpha=.2, fill="#FF6666") +
#xlim(c(48.5, 62.5)) +
ggtitle("Years Histogram", "Worst Case Herring")
ggsave("wch_y_hist.png")
wch_f <- factor(wch_years[[1]])
table(wch_f)
bcm_years <- read_csv("bcm_years.csv")
bcm_years <- bcm_years[,2]
median(bcm_years)
as.numeric(bcm_f)
median(as.numeric(bcm_f))
as.numeric(bcm_years[[1]])
median(as.numeric(bcm_years[[1]]))
median(as.numeric(wcm_years[[1]]))
median(as.numeric(bch_years[[1]]))
median(as.numeric(wch_years[[1]]))
